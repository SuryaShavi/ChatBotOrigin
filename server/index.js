require('dotenv').config();
const express = require('express');
const cors = require('cors');
const OpenAI = require('openai');

const app = express();
app.use(cors()); // allow all origins by default; adjust if you want to restrict
app.use(express.json());

const openai = process.env.OPENAI_API_KEY
  ? new OpenAI({ apiKey: process.env.OPENAI_API_KEY })
  : null;
const USE_OPENAI = !!openai;

// ---------- HEURISTIC ANALYZER ----------
function analyzeHeuristically(code, language = 'auto') {
  const trimmed = code.trim();
  const lines = trimmed.split(/\r?\n/).filter((l) => l.trim().length > 0);
  const lineCount = Math.max(lines.length, 1);

  const lang = (language || 'auto').toLowerCase();

  // language-specific comment detection
  let commentRegex;
  if (lang === 'python') {
    commentRegex = /(^\s*#|"""|''')/gm;
  } else if (lang === 'java' || lang === 'cpp' || lang === 'javascript') {
    commentRegex = /(^\s*\/\/|\/\*|\*)/gm;
  } else {
    // auto / unknown: accept both styles
    commentRegex = /(^\s*\/\/|^\s*#|\/\*|\*)/gm;
  }

  const commentMatches = trimmed.match(commentRegex) || [];
  const commentRatio = commentMatches.length / lineCount; // 0..1

  const hasAIKeywords = /chatgpt|generated by ai|auto-?generated|copilot|openai|gpt/i.test(
    trimmed
  );

  const hasJSONlike = /\{\s*"?[a-zA-Z0-9_]+\"?\s*:/.test(trimmed);

  // "formal" / generic documentation style often used by AI
  const formalCommentRegex =
    /\b(automatically|implementation|generic|intentionally|reusable|demonstration|dataset|normalized result|pipeline|statistical|analytics|summary report|data pipeline|compute stats?)\b/i;
  const hasFormalComments = formalCommentRegex.test(trimmed);

  // casual / human-ish words in comments
  const casualCommentRegex =
    /\b(quick hack|todo|fixme|later|lol|idk|wtf|temp|hacky|oops)\b/i;
  const hasCasualComments = casualCommentRegex.test(trimmed);

  // how many lines start with indentation (uniform formatting)
  const indentedLines = lines.filter((l) => /^\s{2,}\S/.test(l)).length;
  const indentRatio = indentedLines / lineCount;

  const longLines = lines.filter((l) => l.length > 120).length;
  const avgLineLength =
    lines.reduce((sum, l) => sum + l.length, 0) / lineCount;

  const weirdNameRegex = /\b(var_|tmp|foo|bar)[0-9]*\b/;
  const hasWeirdNames = weirdNameRegex.test(trimmed);

  // repeated lines / blocks (very rough)
  const lineFreq = {};
  for (const l of lines) {
    const key = l.trim();
    lineFreq[key] = (lineFreq[key] || 0) + 1;
  }
  const repeatedLines = Object.values(lineFreq).filter((n) => n > 1).length;
  const repeatRatio = repeatedLines / lineCount;

  // ---- SCORE TOWARDS AI vs HUMAN ----
  // score > 0  => AI
  // score < 0  => Human
  let score = 0;
  const reasons = [];

  // Comments: more comments → more human, almost none → more AI
  if (commentRatio < 0.02) {
    score += 2;
    reasons.push('Very few or no comments in the snippet.');
  } else if (commentRatio > 0.25) {
    score -= 2;
    reasons.push('Relatively high comment density suggests human editing.');
  }

  // Comment *style*
  if (hasFormalComments && !hasCasualComments) {
    score += 2;
    reasons.push(
      'Comments use formal, generic wording often seen in AI-generated documentation.'
    );
  }
  if (hasCasualComments) {
    score -= 2;
    reasons.push(
      'Comments contain informal or slang wording, typical of quick human notes.'
    );
  }

  // Indentation / formatting uniformity
  if (indentRatio > 0.85 && longLines === 0) {
    score += 1.5;
    reasons.push('Indentation and formatting look highly uniform and polished.');
  } else if (indentRatio < 0.3) {
    score -= 1;
    reasons.push(
      'Indentation is somewhat inconsistent, which is common in human drafts.'
    );
  }

  // Average line length
  if (avgLineLength > 100) {
    score += 1;
    reasons.push(
      'Many long lines; may come from auto-generated code or formatted output.'
    );
  } else if (avgLineLength < 40 && commentRatio > 0.2 && hasCasualComments) {
    score -= 1;
    reasons.push(
      'Short, informal commented lines suggest incremental human writing.'
    );
  }

  // Repeated lines / blocks
  if (repeatRatio > 0.2) {
    score += 1;
    reasons.push('Repeated code blocks or lines detected.');
  }

  // Weird / ad-hoc variable names → more human
  if (hasWeirdNames && !hasAIKeywords) {
    score -= 1.5;
    reasons.push('Variable naming looks ad-hoc, often seen in human-written code.');
  }

  // JSON-like structure, more common in examples / AI responses for JS
  if (hasJSONlike && (lang === 'javascript' || lang === 'auto')) {
    score += 1;
    reasons.push(
      'Contains structured JSON-like data, common in AI-generated JavaScript examples.'
    );
  }

  // Explicit AI mentions → strong AI vote
  if (hasAIKeywords) {
    score += 5;
    reasons.push('Snippet explicitly references AI tools or GPT models.');
  }

  // --- Tiny snippet handling ---
  // Previously we strongly biased tiny snippets toward "human".
  // Now we only slightly nudge, so short, clean AI code can still be flagged as AI.
  const isTinySnippet = lineCount <= 5 && trimmed.length < 180 && !hasAIKeywords;
  if (isTinySnippet) {
    score -= 0.5;
    reasons.push(
      'Very small snippet with limited structure; slightly nudging toward human-written.'
    );
  }

  // Base magnitude: longer code gives more confidence, but short code still gets some.
  const lengthFactor = Math.min(trimmed.length / 400, 1); // 0..1 (faster ramp)
  const magnitude = Math.min(6, Math.abs(score)) * (0.4 + 0.6 * lengthFactor); // 0..6

  // Map magnitude → confidence 55–95
  let confidence =
    magnitude === 0 ? 55 : Math.min(95, Math.round(60 + magnitude * 5));

  // Decide final type
  let type = 'human';
  if (score > 0.5) {
    type = 'ai';
  } else if (score < -0.5) {
    type = 'human';
  } else {
    // borderline: weight towards human if clearly messy, otherwise lean slightly AI
    if (hasCasualComments || indentRatio < 0.4) {
      type = 'human';
    } else {
      type = 'ai';
    }
    confidence = 55;
    reasons.push('Signals are mixed; classification is low confidence.');
  }

  // Tiny snippets are low-confidence but not forced super low
  if (isTinySnippet) {
    confidence = Math.min(confidence, 70);
  }

  // Ensure at least one reason
  if (reasons.length === 0) {
    reasons.push(
      'Heuristic rules did not strongly match either class; defaulting to human-written.'
    );
  }

  return { type, confidence, reasons };
}

// ---------- OPTIONAL OPENAI ANALYZER ----------
async function analyzeWithOpenAI(code, language, heuristicResult) {
  if (!openai) return heuristicResult;

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4.1-mini',
      // Force valid JSON
      response_format: { type: 'json_object' },
      temperature: 0.1,
      messages: [
        {
          role: 'system',
          content:
            'You are a code-origin classifier. Your job is to decide whether a given code snippet is **ai**-generated or **human**-written. ' +
            'Return ONLY a JSON object with this exact shape: ' +
            '{ "type": "ai" | "human", "confidence": integer (0-100), "reasons": string[] }. ' +
            'The "confidence" field MUST be an integer between 0 and 100. ' +
            'If the code looks polished, generic, tutorial-like, or auto-generated (especially with formal comments), lean toward "ai". ' +
            'If the code looks messy, has small mistakes, inconsistent spacing, casual comments (e.g. "quick hack", "todo", "later"), or very personal style, lean toward "human". ' +
            'Short snippets can still be AI-generated: do not automatically label short code as human.'
        },
        {
          role: 'user',
          content:
            `Language hint: ${language}\n` +
            `Heuristic suggestion: type=${heuristicResult.type}, confidence=${heuristicResult.confidence}, reasons=${heuristicResult.reasons.join(
              '; '
            )}\n\n` +
            `Code (first 4000 chars):\n` +
            code.slice(0, 4000)
        }
      ]
    });

    const raw = response.choices?.[0]?.message?.content ?? '{}';
    const parsed = JSON.parse(raw);

    const type = parsed.type === 'ai' ? 'ai' : 'human';

    let blendedConfidence = heuristicResult.confidence;
    if (typeof parsed.confidence === 'number' && !Number.isNaN(parsed.confidence)) {
      // If the model used 0–1, scale up; otherwise assume 0–100
      let rawC = parsed.confidence;
      if (rawC <= 1) rawC = rawC * 100;

      const clipped = Math.max(1, Math.min(99, rawC));

      // Blend with heuristic confidence but give the model a bit more weight.
      blendedConfidence = Math.round((2 * clipped + heuristicResult.confidence) / 3);
    }

    const aiReasons = Array.isArray(parsed.reasons) ? parsed.reasons : [];
    const reasonsBase =
      aiReasons.length > 0 ? aiReasons : heuristicResult.reasons;

    // Take up to 5 reasons, mixing AI + heuristic (no duplicates)
    const mergedReasons = Array.from(
      new Set([...reasonsBase, ...heuristicResult.reasons])
    ).slice(0, 5);

    return {
      type,
      confidence: blendedConfidence,
      reasons: mergedReasons
    };
  } catch (err) {
    console.error('OpenAI error or JSON parse failed:', err);
    return {
      ...heuristicResult,
      reasons: [
        ...heuristicResult.reasons,
        'AI model response failed or could not be parsed; falling back to heuristic.'
      ]
    };
  }
}

// ---------- ROUTES ----------
app.get('/', (req, res) => {
  res.send('CodeOrigin API is running. POST /analyze with { code, language }.');
});

app.post('/analyze', async (req, res) => {
  const { code, language = 'auto' } = req.body || {};

  if (!code || typeof code !== 'string') {
    return res.status(400).json({ error: 'Code is required.' });
  }

  try {
    const heuristic = analyzeHeuristically(code, language);
    heuristic.model = USE_OPENAI ? 'Heuristic + OpenAI' : 'Heuristic';

    if (!USE_OPENAI) {
      return res.json(heuristic);
    }

    const aiResult = await analyzeWithOpenAI(code, language, heuristic);
    aiResult.model = 'Heuristic + OpenAI';

    return res.json(aiResult);
  } catch (err) {
    console.error(err);
    const fallback = analyzeHeuristically(code, language);
    fallback.model = USE_OPENAI ? 'Heuristic + OpenAI' : 'Heuristic';
    fallback.reasons.push(
      'An internal server error occurred; returned heuristic result.'
    );
    return res.status(500).json({ error: 'Internal error.', ...fallback });
  }
});

// Use process.env.PORT and bind to 0.0.0.0 so render / cloud hosts can reach the server
const PORT = Number(process.env.PORT || 5000);
const HOST = process.env.HOST || '0.0.0.0';

app.listen(PORT, HOST, () => {
  console.log(`CodeOrigin API listening on ${HOST}:${PORT}`);
});
