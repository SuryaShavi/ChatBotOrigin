require('dotenv').config();
const express = require('express');
const cors = require('cors');
const OpenAI = require('openai');

const app = express();
app.use(cors());
app.use(express.json());

const openai =
  process.env.OPENAI_API_KEY ? new OpenAI({ apiKey: process.env.OPENAI_API_KEY }) : null;
const USE_OPENAI = !!openai;

// ---------- HEURISTIC ANALYZER ----------
function analyzeHeuristically(code, language = 'auto') {
  const trimmed = code.trim();
  const lines = trimmed.split(/\r?\n/).filter((l) => l.trim().length > 0);
  const lineCount = Math.max(lines.length, 1);

  const lang = (language || 'auto').toLowerCase();

  // language-specific comment detection
  let commentRegex;
  if (lang === 'python') {
    commentRegex = /(^\s*#|"""|''')/gm;
  } else if (lang === 'java' || lang === 'cpp' || lang === 'javascript') {
    commentRegex = /(^\s*\/\/|\/\*|\*)/gm;
  } else {
    // auto / unknown: accept both styles
    commentRegex = /(^\s*\/\/|^\s*#|\/\*|\*)/gm;
  }

  const commentMatches = trimmed.match(commentRegex) || [];
  const commentRatio = commentMatches.length / lineCount; // 0..1

  const hasAIKeywords = /chatgpt|generated by ai|copilot|openai|gpt/i.test(trimmed);
  const hasJSONlike = /\{\s*"?[a-zA-Z0-9_]+\"?\s*:/.test(trimmed);

  // how many lines start with indentation (uniform formatting)
  const indentedLines = lines.filter((l) => /^\s{2,}\S/.test(l)).length;
  const indentRatio = indentedLines / lineCount;

  const longLines = lines.filter((l) => l.length > 120).length;
  const avgLineLength =
    lines.reduce((sum, l) => sum + l.length, 0) / lineCount;

  const weirdNameRegex = /\b(var_|tmp|foo|bar)[0-9]*\b/;
  const hasWeirdNames = weirdNameRegex.test(trimmed);

  // repeated lines / blocks (very rough)
  const lineFreq = {};
  for (const l of lines) {
    const key = l.trim();
    lineFreq[key] = (lineFreq[key] || 0) + 1;
  }
  const repeatedLines = Object.values(lineFreq).filter((n) => n > 1).length;
  const repeatRatio = repeatedLines / lineCount;

  // ---- SCORE TOWARDS AI vs HUMAN ----
  // score > 0  => AI
  // score < 0  => Human
  let score = 0;
  const reasons = [];

  // Comments: more comments → more human, almost none → more AI
  if (commentRatio < 0.02) {
    score += 2;
    reasons.push('Very few or no comments in the snippet.');
  } else if (commentRatio > 0.25) {
    score -= 2;
    reasons.push('Relatively high comment density suggests human editing.');
  }

  // Indentation / formatting uniformity
  if (indentRatio > 0.8 && longLines === 0) {
    score += 1.5;
    reasons.push('Indentation and formatting look highly uniform.');
  } else if (indentRatio < 0.3) {
    score -= 1;
    reasons.push('Indentation is somewhat inconsistent, which is common in human drafts.');
  }

  // Average line length
  if (avgLineLength > 100) {
    score += 1;
    reasons.push('Many long lines; may come from auto-generated code or formatted output.');
  } else if (avgLineLength < 40 && commentRatio > 0.2) {
    score -= 1;
    reasons.push('Short, commented lines suggest incremental human writing.');
  }

  // Repeated lines / blocks
  if (repeatRatio > 0.2) {
    score += 1;
    reasons.push('Repeated code blocks detected.');
  }

  // Weird / ad-hoc variable names → more human
  if (hasWeirdNames && !hasAIKeywords) {
    score -= 1.5;
    reasons.push('Variable naming looks ad-hoc, often seen in human-written code.');
  }

  // JSON-like structure, more common in examples / AI responses for JS
  if (hasJSONlike && (lang === 'javascript' || lang === 'auto')) {
    score += 1;
    reasons.push('Contains structured JSON-like data, common in AI-generated JS examples.');
  }

  // Explicit AI mentions → strong AI vote
  if (hasAIKeywords) {
    score += 5;
    reasons.push('Snippet explicitly references AI tools or GPT models.');
  }

  // Base magnitude: longer code gives more confidence
  const lengthFactor = Math.min(trimmed.length / 600, 1); // 0..1
  const magnitude = Math.min(6, Math.abs(score)) * (0.4 + 0.6 * lengthFactor); // 0..6

  // Map magnitude → confidence 55–95
  let confidence =
    magnitude === 0 ? 55 : Math.min(95, Math.round(60 + magnitude * 5));

  // Decide final type
  let type = 'human';
  if (score > 0.5) {
    type = 'ai';
  } else if (score < -0.5) {
    type = 'human';
  } else {
    // borderline: nudge by comments
    type = commentRatio > 0.15 ? 'human' : 'ai';
    confidence = 55;
    reasons.push('Signals are mixed; classification is low confidence.');
  }

  // Ensure at least one reason
  if (reasons.length === 0) {
    reasons.push('Heuristic rules did not strongly match either class; defaulting to human-written.');
  }

  return { type, confidence, reasons };
}

// ---------- OPTIONAL OPENAI ANALYZER ----------
async function analyzeWithOpenAI(code, language, heuristicResult) {
  if (!openai) {
    return heuristicResult;
  }

  const modelName = 'gpt-4.1-mini';

  const systemPrompt =
    'You are a code-origin classifier. Given some source code, decide if it is AI-generated or human-written. ' +
    "Respond ONLY with a JSON object with keys: type (\"ai\" or \"human\"), confidence (0-100), reasons (array of 2-4 short strings). " +
    'Do not include any other text.';

  const userContent = `Language: ${language}
Heuristic guess: ${JSON.stringify(heuristicResult)}

Code:
${code.slice(0, 4000)}
`;

  const response = await openai.chat.completions.create({
    model: modelName,
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userContent },
    ],
    temperature: 0.2,
  });

  const raw = response.choices[0].message.content || '{}';

  let parsed;
  try {
    parsed = JSON.parse(raw);
  } catch {
    return {
      ...heuristicResult,
      reasons: [
        ...heuristicResult.reasons,
        'AI model response could not be parsed; falling back to heuristic.',
      ],
    };
  }

  const type = parsed.type === 'ai' ? 'ai' : 'human';
  const confidence =
    typeof parsed.confidence === 'number'
      ? Math.max(1, Math.min(99, Math.round(parsed.confidence)))
      : heuristicResult.confidence;

  const reasons =
    Array.isArray(parsed.reasons) && parsed.reasons.length
      ? parsed.reasons
      : heuristicResult.reasons;

  return { type, confidence, reasons };
}

// ---------- ROUTES ----------
app.get('/', (req, res) => {
  res.send('CodeOrigin API is running. POST /analyze with { code, language }.');
});

app.post('/analyze', async (req, res) => {
  const { code, language = 'auto' } = req.body || {};

  if (!code || typeof code !== 'string') {
    return res.status(400).json({ error: 'Code is required.' });
  }

  try {
    const heuristic = analyzeHeuristically(code, language);

    if (!USE_OPENAI) {
      return res.json(heuristic);
    }

    const aiResult = await analyzeWithOpenAI(code, language, heuristic);
    return res.json(aiResult);
  } catch (err) {
    console.error(err);
    const fallback = analyzeHeuristically(code, language);
    fallback.reasons.push('An internal server error occurred; returned heuristic result.');
    return res.status(500).json({ error: 'Internal error.', ...fallback });
  }
});

const PORT = 5000;
app.listen(PORT, () => {
  console.log(`CodeOrigin API listening on http://localhost:${PORT}`);
});
